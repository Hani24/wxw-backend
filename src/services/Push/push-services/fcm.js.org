const _Base = require('../_Base');

const PUSH_FCM_API_BASE = process.env.PUSH_FCM_API_BASE;
const PUSH_FCM_API_PUSH_PATH = process.env.PUSH_FCM_API_PUSH_PATH;
const PUSH_FCM_API_KEY = process.env.PUSH_FCM_API_KEY;

module.exports = FCM = class FCM extends _Base{

  constructor(App, params={}){
    super(App, params);
    this.base = PUSH_FCM_API_BASE;
    this.pushPath = PUSH_FCM_API_PUSH_PATH;
    this._key = PUSH_FCM_API_KEY;

  }

  createPacket(
    { title='', message='', icon='', image='', data={}, link='', href=''}={}, 
    debug=false
  ){

    if( debug )
      console.json({ createPacket: { title, message } });

    const tag = `tag-${ this.App.BCrypt.randomSecureToken(8) }`;
    const notificationId = `notificationId-${ this.App.BCrypt.randomSecureToken(8) }`;
    const channelId = 'default';
    const experienceId = this.App.getAppName();
    image = this.App.S3.getUrlByName(icon || image || 'notifications.default.png');
    link = (link || href || '');

    title = (this.App.isString(title) && title.trim().length ? title.trim() : '');
    message = (this.App.isString(message) && message.trim().length ? message.trim() : '');

    // https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#Message.FIELDS.data
    const notification_t = {
      to: '',
      name: `name-${tag}`, // /*/messages/{message_id}
      topic: `topic-${tag}`,
      tag,
      _tag: tag,
      // notificationId,
      // channelId,
      // experienceId,
      channel_id: channelId,
      notification: {
        title: title,
        body: message,
        image: image,
        tag,
      },
      data,
      android:{
        collapse_key: `col-key-${tag}`,
        ttl:'86400s',
        notification: {
          // click_action: 'OPEN_ACTIVITY_1'
          title: title,
          body: message,
          image: image,
          tag,
          channel_id: channelId,
          image,
        }
      },
      apns: {
        headers: {
          'apns-priority': '5',
        },
        payload: {
          // aps: {
          //   "category": "NEW_MESSAGE_CATEGORY"
          // },
          sound : 'default',
          priority : 'high',
          aps: {
            alert : JSON.stringify({
              title : title,
              body : message,
              'launch-image': image, 
            }),
            'content-available': 1,
            badge : 3,
            'mutable-content': 1,
            category: 'NEW_MESSAGE_CATEGORY'
          },
        }
      },
      // webpush:{
      //   headers:{
      //     TTL: '86400'
      //   }
      // }
    };

    if( debug )
      console.json({ notification_t });
    return notification_t;

  }

  sendToUserByIdInBackground( userId, data={}, debug=false ){
    this.sendToUserByIdAsync( userId, data, debug );
    return true;
  }

  async sendToUserByIdAsync( userId, data={}, debug=false ){

    const packet_t = this.createPacket( data, debug );
    const mFcmsRes = await this.App.getModel('Session').getAllRecentFcmTokensByUserId( userId );

    if( debug ){
      console.json({userId, packet_t});
      console.json({ mFcmsRes });
    }

    if( !mFcmsRes.success )
      return mFcmsRes;

    const pushRes = {
      userId,
      debug,
      success: 0,
      failure: 0,
      devices: {},
    };

    console.log(`  sendToUserByIdAsync: userId: ${userId}`)
    for( const deviceId of Object.keys(mFcmsRes.data) ){
      const deviceFcms = mFcmsRes.data[ deviceId ];
      console.warn(`  deviceFcms: deviceId: ${deviceId}, total => [${deviceFcms.length}]`);

      if( !this.App.isArray(deviceFcms) || !deviceFcms.length ){
        console.warn(`  deviceFcms: !== []`);
        continue;
      }

      for( const mRecord of deviceFcms )
        console.log(`    mRecord: ${mRecord.id}: userId: ${mRecord.userId}, deviceId: ${mRecord.deviceId}: token: ${mRecord.fcm.substr(0,12)}...`);

      if( debug )
        console.debug(`  deviceId: ${deviceId}: total push-tokens: ${deviceFcms.length}`);
      const pushToDeviceRes = await this._sendToMany( packet_t, deviceFcms, userId, debug );

      if( this.App.isUndefined( pushRes.devices[ deviceId ] ) ){
        pushRes.devices[ deviceId ] = {
          success: 0,
          failure: 0,
          tag: 'n/a',
        };        
      }

      pushRes.success += pushToDeviceRes.data.success;
      pushRes.failure += pushToDeviceRes.data.failure;

      pushRes.devices[ deviceId ].success += pushToDeviceRes.data.success;
      pushRes.devices[ deviceId ].failure += pushToDeviceRes.data.failure;
      pushRes.devices[ deviceId ].tag = pushToDeviceRes.data.tag;
      console.log(`    #deviceId: ${deviceId}, success: ${pushToDeviceRes.data.success}, failure: ${pushToDeviceRes.data.failure}, tag: ${pushToDeviceRes.data.tag}`);

    }

    const success = (pushRes.success > 0);
    const message = (success ? 'success': 'no valid fcm tokens where found');
    if( debug )
      console.json({success, message, data: pushRes});

    return { success, message, data: pushRes };

  }

  broadcastInBackground( data={}, debug=false ){
    this.broadcastAsync( data, debug );
    return true;
  }

  async broadcastAsync( data={}, debug=false, dryRun=false ){

    const mFcmsRes = await this.App.getModel('Session').getAllRecentFcmTokens();
    if( debug )
      console.json({ mFcmsRes });

    if( !mFcmsRes.success )
      return mFcmsRes;

    const packet_t = this.createPacket( data, debug );
    if( debug && dryRun )
      console.json({packet_t});

    return dryRun 
      ? {success: false, message: 'dryRun'} 
      : await this._sendToMany( packet_t, mFcmsRes.data, false, debug );

  }

  async _sendToMany( packet_t, fcms, userId=false, debug=false ){

    const data = {
      tag: packet_t._tag,
      success: 0,
      failure: 0,
      userId,
      debug,
    };

    // [fcm-notification]
    for( const mRecord of fcms ){

      try{

        packet_t.to = mRecord.fcm || mRecord.fcmPushToken;
        const pushRes = await this.send( packet_t, debug );

        if( debug ){
          console.debug({pushRes});
          console.debug({packet_t});
        }

        if( this.App.isNull(pushRes.data) ){
          pushRes.data = {
            failure: 1,
          };
        }

        if( !pushRes.success || pushRes.data.failure ){
          const fcmMessage = (this.App.isArray(pushRes.data.results) && this.App.isObject(pushRes.data.results[0]) 
            ? pushRes.data.results[0].error || 'no-fcm-error-message'
            : pushRes.message
          );

          console.error(` #fcm:_sendToMany: [res] ${fcmMessage}: session: ${mRecord.id}, user: ${mRecord.userId} `);

          try{

            if( !this.App.isObject(pushRes.data) || ( this.App.isUndefined(pushRes.data.success) || this.App.isUndefined(pushRes.data.failure) ) )
              throw Error(` #fcm:push:_sendToMany: not valid response from google. no cleanup will be applied`);

            // InternalServerError: <= not this, it is google-side server error
            if( !['NotRegistered','MismatchSenderId'].includes(fcmMessage) ){
              console.debug({mRecord});
              console.debug({pushRes});
              console.debug({packet_t});
            }else{

              // remove old/non-working clients push-tokens for the next run
              const updateSessionRes = await this.App.getModel('Session').update(
                { fcmPushToken: '' },
                { where: {id: mRecord.id} }
              );

              if( !this.App.isArray(updateSessionRes) ){
                console.warn(`    #Firebase: could not remove non-working/local fcm push-token`);
              }else{
                console.ok(`    #Firebase: removed non-working/local fcm push-token`);
              }
              console.debug({updateSessionRes});

            }

          }catch(e){
            console.error(`    #Firebase: ${e.message}`);
          }

        }

        data.success += +(!! pushRes.data.success);
        data.failure += +(!! pushRes.data.failure);

        // if it was pushed to one user+ not as broadcast
        // if( userId && (!! pushRes.data.success) ){
        //   if( debug ){
        //     console.debug(`it was pushed to one user+ not as broadcast`);
        //     console.json({userId});
        //   }
        //   break;
        // }

        await console.sleep( this.getPushDelay() );

      }catch(e){
        console.error(` #fcm:_sendToMany: [loop] ${e.message} `);
      }

    }

    const success = (data.success > 0);
    const message = (success ? 'success': 'no valid fcm tokens where found');

    if( debug || !success ){
      console.debug({
        title: packet_t.notification.title, 
        body: packet_t.notification.body,
        devices: fcms.map((mRecord)=>{ return {[ mRecord.deviceId ]: `${mRecord.fcm.substr(0, 12)}...`} }),
        res: { success, message, data },
      });
    }

    return { success, message, data };

  }

  async send(packet_t={}, debug=false){
    const headers = { 
      'Content-Type': 'application/json',
      'Authorization': `key=${ this._key }`,
    };

    const sendPushRes = await this._post( this.pushPath, packet_t, headers);

    if( debug ){
      console.json({ packet_t });
      console.json({ headers });
      console.json({ sendPushRes });
    }

    return sendPushRes;
  }
}
